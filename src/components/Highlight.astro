---
/**
 * Highlight.astro
 *
 * Usage:
 * Wrap any text you want to highlight in your article with the <Highlight> component:
 *
 * Example:
 * <Highlight>Default yellow highlight</Highlight>
 * <Highlight color="green">Green highlight</Highlight>
 * <Highlight color="blue" delay={1500} bold>Bold blue highlight with 1.5s delay</Highlight>
 * <Highlight sequential="block">Sequential within parent block</Highlight>
 * <Highlight sequential="page">Sequential across entire page</Highlight>
 *
 * Props:
 *  - bold?: boolean
 *      If true, the highlighted text will be bold.
 *  - color?: string
 *      One of "yellow", "green", "blue", "pink", "purple".
 *      Default is "yellow".
 *  - delay?: number
 *      Delay in milliseconds before starting the highlight animation.
 *      Default is 1000 ms.
 *  - sequential?: "block" | "page" | false
 *      Controls whether highlights appear sequentially.
 *        false   = independent highlights (default behavior for normal text)
 *        "block" = sequential within the same parent container
 *        "page"  = sequential across the entire page
 */
const { bold = false, color = 'yellow', delay = 1000, sequential = 'page' } = Astro.props;

// Tailwind-inspired color palette for highlights
const palette = {
  yellow: { bg: '#FEF9C3', text: '#854D0E' },
  green:  { bg: '#BBF7D0', text: '#065F46' },
  blue:   { bg: '#BFDBFE', text: '#1E3A8A' },
  pink:   { bg: '#FBCFE8', text: '#9D174D' },
  purple: { bg: '#E9D5FF', text: '#581C87' },
};

// Pick the color from palette, fallback to yellow if invalid
const { bg, text } = palette[color] ?? palette.yellow;
---

<!-- Highlight span -->
<!-- data-hl: Marker for JS to attach observer -->
<!-- data-sequential: Pass sequential mode to JS -->
<span
  class={`hl relative inline-block px-1 rounded`}
  data-hl
  data-sequential={sequential}
  style={`--bg:${bg}; --text:${text}; --delay:${delay}ms; --bold:${bold ? 600 : 400};`}
>
  <slot />
</span>

<style>
.hl {
  font-weight: 400; /* default normal weight */
  background-image: linear-gradient(var(--bg), var(--bg));
  background-repeat: no-repeat;
  background-position: left center;
  background-size: 0% 100%;
}

.hl.is-visible {
  /* When active, fill the background and apply text color & bold */
  background-size: 100% 100%;
  color: var(--text);        /* Highlight color */
  font-weight: var(--bold);   /* Bold if prop is true */
  
  /* Animate background size, color, and font weight */
  transition: 
    background-size 800ms cubic-bezier(0.22,1,0.36,1) var(--delay),
    color 800ms cubic-bezier(0.22,1,0.36,1) var(--delay),
    font-weight 800ms cubic-bezier(0.22,1,0.36,1) var(--delay);
}
</style>

<script type="text/javascript">
  console.log('highlight.astro - init');
(() => {
  console.log('highlight.astro - page loaded');
  // 1ï¸âƒ£ Prevent running the script multiple times creating the custom variable __HL_INIT__
  // if (window.__HL_INIT__){
  //   console.log('window.__HL_INIT__ jÃ¡ iniciado, retornando',window.__HL_INIT__)
  //   return;
  // }
  // console.log('iniciando variavel global window.__HL_INIT__',window.__HL_INIT__)
  // window.__HL_INIT__ = true;

  // Helper: init highlights logic (independent + sequential)
  function initHighlights() {
    // 2ï¸âƒ£ Collect all highlight elements
    const highlights = [...document.querySelectorAll('[data-hl]')];
    console.log('qty de highlights a processar', highlights.length)

    // 3ï¸âƒ£ Handle independent highlights (sequential = false)
    const independentHighlights = highlights.filter(
      h => !h.dataset.sequential || h.dataset.sequential === 'false'
    );
    independentHighlights.forEach(el => {
      const io = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // 4ï¸âƒ£ Add the class to trigger CSS animation
            // console.log('adicionando a classe is-visible no elemento', el)
            el.classList.add('is-visible');
            io.unobserve(el); // Stop observing after animation triggered
          }
        });
      }, { threshold: 0.8 }); // Trigger when 80% of the element is visible
      io.observe(el);
    });

    // 5ï¸âƒ£ Handle sequential highlights (block or page)
    const sequentialHighlights = highlights.filter(
      h => h.dataset.sequential && h.dataset.sequential !== 'false'
    );

    // 6ï¸âƒ£ Group highlights by block or page
    const groups = {};
    sequentialHighlights.forEach(el => {
      const key = el.dataset.sequential === 'block' ? el.parentElement : 'page';
      if (!groups[key]) groups[key] = [];
      groups[key].push(el);
    });

    // 7ï¸âƒ£ Iterate each group and process sequentially
    Object.values(groups).forEach(group => {
      let queue = []; // Queue of elements that will animate

      // Function to start next highlight in the queue
      function startNext() {
        if (queue.length === 0) return;
        const el = queue.shift();
        const delay = parseInt(el.style.getPropertyValue('--delay')) || 1000;
        const transition = 800;
        setTimeout(() => {
            // console.log('adicionando a classe is-visible no elemento', el)
          el.classList.add('is-visible'); // Trigger animation
          setTimeout(startNext, transition); // Start next after animation completes
        }, delay);
      }

      // 8ï¸âƒ£ Attach IntersectionObserver to each element in the group
      group.forEach(el => {
        const io = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if (
              entry.isIntersecting &&
              !queue.includes(el) &&
              !el.classList.contains('is-visible')
            ) {
              queue.push(el);   // Add to queue
              io.unobserve(el); // Stop observing
              if (queue.length === 1) startNext(); // Start immediately if first
            }
          });
        }, { threshold: 0.8 });
        io.observe(el);
      });
    });
  }

  // // ðŸ”§ Patch: delay init until after layout is painted (fix for client-side navigation)
  // function delayedInit() {
  //   console.log('chamando delayed init')
  //   requestAnimationFrame(() => {
  //     requestAnimationFrame(() => {
  //       initHighlights();
  //     });
  //   });
  // }

  // Run once on initial load
  console.log('chamando init highlights')
  setTimeout(() => initHighlights(), 1000)
  

  // // Run also after client-side navigation
  // document.addEventListener("astro:after-swap", delayedInit);
  // document.addEventListener("astro:page-load", delayedInit);
})();
</script>
