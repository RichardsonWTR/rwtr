---
/**
 * Highlight.astro
 *
 * Usage:
 * Wrap any text you want to highlight in your article with the <Highlight> component:
 *
 * Example:
 * <Highlight>Default yellow highlight</Highlight>
 * <Highlight color="green">Green highlight</Highlight>
 * <Highlight color="blue" delay={1500} bold>Bold blue highlight with 1.5s delay</Highlight>
 * <Highlight sequential="block">Sequential within parent block</Highlight>
 * <Highlight sequential="page">Sequential across entire page</Highlight>
 *
 * Props:
 *  - bold?: boolean
 *      If true, the highlighted text will be bold.
 *  - color?: string
 *      One of "yellow", "green", "blue", "pink", "purple".
 *      Default is "yellow".
 *  - delay?: number
 *      Delay in milliseconds before starting the highlight animation.
 *      Default is 1000 ms.
 *  - sequential?: "block" | "page" | false
 *      Controls whether highlights appear sequentially.
 *        false   = independent highlights (default behavior for normal text)
 *        "block" = sequential within the same parent container
 *        "page"  = sequential across the entire page
 */
const { bold = false, color = 'yellow', delay = 1000, sequential = 'page' } = Astro.props;

// Tailwind-inspired color palette for highlights
const palette = {
  yellow: { bg: '#FEF9C3', text: '#854D0E' },
  green:  { bg: '#BBF7D0', text: '#065F46' },
  blue:   { bg: '#BFDBFE', text: '#1E3A8A' },
  pink:   { bg: '#FBCFE8', text: '#9D174D' },
  purple: { bg: '#E9D5FF', text: '#581C87' },
};

// Pick the color from palette, fallback to yellow if invalid
const { bg, text } = palette[color] ?? palette.yellow;
---

<!-- Highlight span -->
<!-- data-hl: Marker for JS to attach observer -->
<!-- data-sequential: Pass sequential mode to JS -->
<span
  class={`hl relative inline-block px-1 rounded`}
  data-hl
  data-sequential={sequential}
  style={`--bg:${bg}; --text:${text}; --delay:${delay}ms; --bold:${bold ? 600 : 400};`}
>
  <slot />
</span>

<style>
.hl {
  font-weight: 400; /* default normal weight */
  background-image: linear-gradient(var(--bg), var(--bg));
  background-repeat: no-repeat;
  background-position: left center;
  background-size: 0% 100%;
}

.hl.is-visible {
  /* When active, fill the background and apply text color & bold */
  background-size: 100% 100%;
  color: var(--text);        /* Highlight color */
  font-weight: var(--bold);   /* Bold if prop is true */
  
  /* Animate background size, color, and font weight */
  transition: 
    background-size 800ms cubic-bezier(0.22,1,0.36,1) var(--delay),
    color 800ms cubic-bezier(0.22,1,0.36,1) var(--delay),
    font-weight 800ms cubic-bezier(0.22,1,0.36,1) var(--delay);
}
</style>

<script type="text/javascript">
  console.log('highlight.astro - init');
(() => {
  console.log('highlight.astro - page loaded');
  // 1️⃣ Prevent running the script multiple times creating the custom variable __HL_INIT__
  if (document.querySelectorAll('[data-hl]:not(.is-visible)').length == 0){
    console.log('não há itens a processsar, retornando')
    return;
  }
  console.log('qtd de itens a processar', document.querySelectorAll('[data-hl]:not(.is-visible)').length)
  

  // Helper: init highlights logic (independent + sequential)
  function initHighlights() {
    // 2️⃣ Collect all highlight elements (skip already visible)
    const highlights = [...document.querySelectorAll('[data-hl]:not(.is-visible)')];

    // 3️⃣ Handle independent highlights (sequential = false)
    const independentHighlights = highlights.filter(
      h => !h.dataset.sequential || h.dataset.sequential === 'false'
    );
    independentHighlights.forEach(el => {
      const io = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // 4️⃣ Add the class to trigger CSS animation
            // Use helper to ensure inline styles + class are applied in a way that works across swaps
            applyInlineHighlight(entry.target);
            io.unobserve(entry.target); // Stop observing after animation triggered
          }
        });
      }, { threshold: 0.8 }); // Trigger when 80% of the element is visible
      io.observe(el);
    });

    // 5️⃣ Handle sequential highlights (block or page)
    const sequentialHighlights = highlights.filter(
      h => h.dataset.sequential && h.dataset.sequential !== 'false'
    );

    // 6️⃣ Group highlights by block or page
    const groups = {};
    sequentialHighlights.forEach(el => {
      const key = el.dataset.sequential === 'block' ? el.parentElement : 'page';
      if (!groups[key]) groups[key] = [];
      groups[key].push(el);
    });

    // 7️⃣ Iterate each group and process sequentially
    Object.values(groups).forEach(group => {
      let queue = []; // Queue of elements that will animate

      // Function to start next highlight in the queue
      function startNext() {
        if (queue.length === 0) return;
        const el = queue.shift();

        // If node was disconnected (swap), skip it quickly
        if (!el.isConnected) {
          console.log('skipping disconnected queued element', el);
          // allow microtask then continue with next
          setTimeout(startNext, 0);
          return;
        }

        const delayMsRaw = el.style.getPropertyValue('--delay') || '1000ms';
        const delayMs = delayMsRaw.trim();
        const transition = 800;
        setTimeout(() => {
          // Apply via helper (sets inline transition then final properties)
          applyInlineHighlight(el);
          setTimeout(startNext, transition); // Start next after animation completes
        }, parseInt(delayMs) || 1000);
      }

      // 8️⃣ Attach IntersectionObserver to each element in the group
      group.forEach(observedEl => {
        const io = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            const target = entry.target;
            if (
              entry.isIntersecting &&
              !queue.includes(target) &&
              !target.classList.contains('is-visible')
            ) {
              queue.push(target);   // Add to queue (use the entry.target)
              io.unobserve(target); // Stop observing
              if (queue.length === 1) startNext(); // Start immediately if first
            }
          });
        }, { threshold: 0.8 });
        io.observe(observedEl);
      });
    });

  }

  // helper: apply inline highlight styles (minimal, forces proper animation across swaps)
function applyInlineHighlight(el) {
  try {
    const delayRaw = el.style.getPropertyValue('--delay') || '1000ms';
    const delay = delayRaw.trim();
    const textColor = el.style.getPropertyValue('--text') || '';
    const boldVal = el.style.getPropertyValue('--bold') || '';

    // Ensure baseline background styles inline (in case scoped CSS was lost)
    el.style.backgroundImage = `linear-gradient(${el.style.getPropertyValue('--bg')}, ${el.style.getPropertyValue('--bg')})`;
    el.style.backgroundRepeat = 'no-repeat';
    el.style.backgroundPosition = 'left center';
    el.style.backgroundSize = '0% 100%'; // start collapsed

    // Set transitions
    const transition = `background-size 800ms cubic-bezier(0.22,1,0.36,1) ${delay}, color 800ms cubic-bezier(0.22,1,0.36,1) ${delay}, font-weight 800ms cubic-bezier(0.22,1,0.36,1) ${delay}`;
    el.style.transition = transition;

    // Force reflow
    void el.offsetWidth;

    // Animate to visible state
    requestAnimationFrame(() => {
      if (textColor) el.style.color = textColor;
      if (boldVal) el.style.fontWeight = boldVal;
      el.style.backgroundSize = '100% 100%';
      if (!el.classList.contains('is-visible')) el.classList.add('is-visible');
      console.log('adicionando is-visible (inline)', el);
    });
  } catch (e) {
    try { el.classList.add('is-visible'); } catch (_) {}
  }
}



  // // 🔧 Patch: delay init until after layout is painted (fix for client-side navigation)
  function delayedInit() {
    console.log('chamando delayed init')
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        initHighlights();
      });
    });
  }

  // Run once on initial load
  console.log('chamando init highlights')
  setTimeout(() => initHighlights(), 1000)
  

  // Run also after client-side navigation
  document.addEventListener("astro:after-swap", delayedInit);
  document.addEventListener("astro:page-load", delayedInit);
})();
</script>
